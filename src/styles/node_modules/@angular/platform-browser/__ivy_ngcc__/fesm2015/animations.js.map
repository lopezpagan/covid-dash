{"version":3,"sources":["/Users/lopezpagan/REPO/bitbucket/devxlab/betel.app/node_modules/@angular/platform-browser/fesm2015/animations.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;AAiBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA8BC,oIAGC;;;;;;;;;;;kCAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsVD,uIAGC;;;;;;;;;6IAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiWD,0IAGC;;;;;;;;;;;;gHAMA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAmED;;;;;;;;0BAMC;;;;;;;;CAMD;;;;;;;;0BAMC","file":"animations.js","sourcesContent":["/**\n * @license Angular v9.0.2\n * (c) 2010-2020 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport { ViewEncapsulation, Injectable, RendererFactory2, Inject, NgZone, InjectionToken, NgModule } from '@angular/core';\nimport { ɵDomRendererFactory2, BrowserModule } from '@angular/platform-browser';\nimport { AnimationBuilder, sequence, AnimationFactory } from '@angular/animations';\nimport { ɵAnimationEngine, AnimationDriver, ɵAnimationStyleNormalizer, ɵsupportsWebAnimations, ɵWebAnimationsDriver, ɵCssKeyframesDriver, ɵWebAnimationsStyleNormalizer, ɵNoopAnimationDriver } from '@angular/animations/browser';\nimport { DOCUMENT } from '@angular/common';\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/animation_builder.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass BrowserAnimationBuilder extends AnimationBuilder {\n    /**\n     * @param {?} rootRenderer\n     * @param {?} doc\n     */\n    constructor(rootRenderer, doc) {\n        super();\n        this._nextAnimationId = 0;\n        /** @type {?} */\n        const typeData = (/** @type {?} */ ({\n            id: '0',\n            encapsulation: ViewEncapsulation.None,\n            styles: [],\n            data: { animation: [] }\n        }));\n        this._renderer = (/** @type {?} */ (rootRenderer.createRenderer(doc.body, typeData)));\n    }\n    /**\n     * @param {?} animation\n     * @return {?}\n     */\n    build(animation) {\n        /** @type {?} */\n        const id = this._nextAnimationId.toString();\n        this._nextAnimationId++;\n        /** @type {?} */\n        const entry = Array.isArray(animation) ? sequence(animation) : animation;\n        issueAnimationCommand(this._renderer, null, id, 'register', [entry]);\n        return new BrowserAnimationFactory(id, this._renderer);\n    }\n}\nBrowserAnimationBuilder.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nBrowserAnimationBuilder.ctorParameters = () => [\n    { type: RendererFactory2 },\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    BrowserAnimationBuilder.prototype._nextAnimationId;\n    /**\n     * @type {?}\n     * @private\n     */\n    BrowserAnimationBuilder.prototype._renderer;\n}\nclass BrowserAnimationFactory extends AnimationFactory {\n    /**\n     * @param {?} _id\n     * @param {?} _renderer\n     */\n    constructor(_id, _renderer) {\n        super();\n        this._id = _id;\n        this._renderer = _renderer;\n    }\n    /**\n     * @param {?} element\n     * @param {?=} options\n     * @return {?}\n     */\n    create(element, options) {\n        return new RendererAnimationPlayer(this._id, element, options || {}, this._renderer);\n    }\n}\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    BrowserAnimationFactory.prototype._id;\n    /**\n     * @type {?}\n     * @private\n     */\n    BrowserAnimationFactory.prototype._renderer;\n}\nclass RendererAnimationPlayer {\n    /**\n     * @param {?} id\n     * @param {?} element\n     * @param {?} options\n     * @param {?} _renderer\n     */\n    constructor(id, element, options, _renderer) {\n        this.id = id;\n        this.element = element;\n        this._renderer = _renderer;\n        this.parentPlayer = null;\n        this._started = false;\n        this.totalTime = 0;\n        this._command('create', options);\n    }\n    /**\n     * @private\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    _listen(eventName, callback) {\n        return this._renderer.listen(this.element, `@@${this.id}:${eventName}`, callback);\n    }\n    /**\n     * @private\n     * @param {?} command\n     * @param {...?} args\n     * @return {?}\n     */\n    _command(command, ...args) {\n        return issueAnimationCommand(this._renderer, this.element, this.id, command, args);\n    }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    onDone(fn) { this._listen('done', fn); }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    onStart(fn) { this._listen('start', fn); }\n    /**\n     * @param {?} fn\n     * @return {?}\n     */\n    onDestroy(fn) { this._listen('destroy', fn); }\n    /**\n     * @return {?}\n     */\n    init() { this._command('init'); }\n    /**\n     * @return {?}\n     */\n    hasStarted() { return this._started; }\n    /**\n     * @return {?}\n     */\n    play() {\n        this._command('play');\n        this._started = true;\n    }\n    /**\n     * @return {?}\n     */\n    pause() { this._command('pause'); }\n    /**\n     * @return {?}\n     */\n    restart() { this._command('restart'); }\n    /**\n     * @return {?}\n     */\n    finish() { this._command('finish'); }\n    /**\n     * @return {?}\n     */\n    destroy() { this._command('destroy'); }\n    /**\n     * @return {?}\n     */\n    reset() { this._command('reset'); }\n    /**\n     * @param {?} p\n     * @return {?}\n     */\n    setPosition(p) { this._command('setPosition', p); }\n    /**\n     * @return {?}\n     */\n    getPosition() { return 0; }\n}\nif (false) {\n    /** @type {?} */\n    RendererAnimationPlayer.prototype.parentPlayer;\n    /**\n     * @type {?}\n     * @private\n     */\n    RendererAnimationPlayer.prototype._started;\n    /** @type {?} */\n    RendererAnimationPlayer.prototype.totalTime;\n    /** @type {?} */\n    RendererAnimationPlayer.prototype.id;\n    /** @type {?} */\n    RendererAnimationPlayer.prototype.element;\n    /**\n     * @type {?}\n     * @private\n     */\n    RendererAnimationPlayer.prototype._renderer;\n}\n/**\n * @param {?} renderer\n * @param {?} element\n * @param {?} id\n * @param {?} command\n * @param {?} args\n * @return {?}\n */\nfunction issueAnimationCommand(renderer, element, id, command, args) {\n    return renderer.setProperty(element, `@@${id}:${command}`, args);\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/animation_renderer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/** @type {?} */\nconst ANIMATION_PREFIX = '@';\n/** @type {?} */\nconst DISABLE_ANIMATIONS_FLAG = '@.disabled';\n/**\n * @record\n */\nfunction RecursiveAnimationTriggerMetadata() { }\nclass AnimationRendererFactory {\n    /**\n     * @param {?} delegate\n     * @param {?} engine\n     * @param {?} _zone\n     */\n    constructor(delegate, engine, _zone) {\n        this.delegate = delegate;\n        this.engine = engine;\n        this._zone = _zone;\n        this._currentId = 0;\n        this._microtaskId = 1;\n        this._animationCallbacksBuffer = [];\n        this._rendererCache = new Map();\n        this._cdRecurDepth = 0;\n        this.promise = Promise.resolve(0);\n        engine.onRemovalComplete = (/**\n         * @param {?} element\n         * @param {?} delegate\n         * @return {?}\n         */\n        (element, delegate) => {\n            // Note: if an component element has a leave animation, and the component\n            // a host leave animation, the view engine will call `removeChild` for the parent\n            // component renderer as well as for the child component renderer.\n            // Therefore, we need to check if we already removed the element.\n            if (delegate && delegate.parentNode(element)) {\n                delegate.removeChild(element.parentNode, element);\n            }\n        });\n    }\n    /**\n     * @param {?} hostElement\n     * @param {?} type\n     * @return {?}\n     */\n    createRenderer(hostElement, type) {\n        /** @type {?} */\n        const EMPTY_NAMESPACE_ID = '';\n        // cache the delegates to find out which cached delegate can\n        // be used by which cached renderer\n        /** @type {?} */\n        const delegate = this.delegate.createRenderer(hostElement, type);\n        if (!hostElement || !type || !type.data || !type.data['animation']) {\n            /** @type {?} */\n            let renderer = this._rendererCache.get(delegate);\n            if (!renderer) {\n                renderer = new BaseAnimationRenderer(EMPTY_NAMESPACE_ID, delegate, this.engine);\n                // only cache this result when the base renderer is used\n                this._rendererCache.set(delegate, renderer);\n            }\n            return renderer;\n        }\n        /** @type {?} */\n        const componentId = type.id;\n        /** @type {?} */\n        const namespaceId = type.id + '-' + this._currentId;\n        this._currentId++;\n        this.engine.register(namespaceId, hostElement);\n        /** @type {?} */\n        const registerTrigger = (/**\n         * @param {?} trigger\n         * @return {?}\n         */\n        (trigger) => {\n            if (Array.isArray(trigger)) {\n                trigger.forEach(registerTrigger);\n            }\n            else {\n                this.engine.registerTrigger(componentId, namespaceId, hostElement, trigger.name, trigger);\n            }\n        });\n        /** @type {?} */\n        const animationTriggers = (/** @type {?} */ (type.data['animation']));\n        animationTriggers.forEach(registerTrigger);\n        return new AnimationRenderer(this, namespaceId, delegate, this.engine);\n    }\n    /**\n     * @return {?}\n     */\n    begin() {\n        this._cdRecurDepth++;\n        if (this.delegate.begin) {\n            this.delegate.begin();\n        }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n    _scheduleCountTask() {\n        // always use promise to schedule microtask instead of use Zone\n        this.promise.then((/**\n         * @return {?}\n         */\n        () => { this._microtaskId++; }));\n    }\n    /**\n     * \\@internal\n     * @param {?} count\n     * @param {?} fn\n     * @param {?} data\n     * @return {?}\n     */\n    scheduleListenerCallback(count, fn, data) {\n        if (count >= 0 && count < this._microtaskId) {\n            this._zone.run((/**\n             * @return {?}\n             */\n            () => fn(data)));\n            return;\n        }\n        if (this._animationCallbacksBuffer.length == 0) {\n            Promise.resolve(null).then((/**\n             * @return {?}\n             */\n            () => {\n                this._zone.run((/**\n                 * @return {?}\n                 */\n                () => {\n                    this._animationCallbacksBuffer.forEach((/**\n                     * @param {?} tuple\n                     * @return {?}\n                     */\n                    tuple => {\n                        const [fn, data] = tuple;\n                        fn(data);\n                    }));\n                    this._animationCallbacksBuffer = [];\n                }));\n            }));\n        }\n        this._animationCallbacksBuffer.push([fn, data]);\n    }\n    /**\n     * @return {?}\n     */\n    end() {\n        this._cdRecurDepth--;\n        // this is to prevent animations from running twice when an inner\n        // component does CD when a parent component instead has inserted it\n        if (this._cdRecurDepth == 0) {\n            this._zone.runOutsideAngular((/**\n             * @return {?}\n             */\n            () => {\n                this._scheduleCountTask();\n                this.engine.flush(this._microtaskId);\n            }));\n        }\n        if (this.delegate.end) {\n            this.delegate.end();\n        }\n    }\n    /**\n     * @return {?}\n     */\n    whenRenderingDone() { return this.engine.whenRenderingDone(); }\n}\nAnimationRendererFactory.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nAnimationRendererFactory.ctorParameters = () => [\n    { type: RendererFactory2 },\n    { type: ɵAnimationEngine },\n    { type: NgZone }\n];\nif (false) {\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._currentId;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._microtaskId;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._animationCallbacksBuffer;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._rendererCache;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._cdRecurDepth;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype.promise;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype.delegate;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype.engine;\n    /**\n     * @type {?}\n     * @private\n     */\n    AnimationRendererFactory.prototype._zone;\n}\nclass BaseAnimationRenderer {\n    /**\n     * @param {?} namespaceId\n     * @param {?} delegate\n     * @param {?} engine\n     */\n    constructor(namespaceId, delegate, engine) {\n        this.namespaceId = namespaceId;\n        this.delegate = delegate;\n        this.engine = engine;\n        this.destroyNode = this.delegate.destroyNode ? (/**\n         * @param {?} n\n         * @return {?}\n         */\n        (n) => (/** @type {?} */ (delegate.destroyNode))(n)) : null;\n    }\n    /**\n     * @return {?}\n     */\n    get data() { return this.delegate.data; }\n    /**\n     * @return {?}\n     */\n    destroy() {\n        this.engine.destroy(this.namespaceId, this.delegate);\n        this.delegate.destroy();\n    }\n    /**\n     * @param {?} name\n     * @param {?=} namespace\n     * @return {?}\n     */\n    createElement(name, namespace) {\n        return this.delegate.createElement(name, namespace);\n    }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    createComment(value) { return this.delegate.createComment(value); }\n    /**\n     * @param {?} value\n     * @return {?}\n     */\n    createText(value) { return this.delegate.createText(value); }\n    /**\n     * @param {?} parent\n     * @param {?} newChild\n     * @return {?}\n     */\n    appendChild(parent, newChild) {\n        this.delegate.appendChild(parent, newChild);\n        this.engine.onInsert(this.namespaceId, newChild, parent, false);\n    }\n    /**\n     * @param {?} parent\n     * @param {?} newChild\n     * @param {?} refChild\n     * @return {?}\n     */\n    insertBefore(parent, newChild, refChild) {\n        this.delegate.insertBefore(parent, newChild, refChild);\n        this.engine.onInsert(this.namespaceId, newChild, parent, true);\n    }\n    /**\n     * @param {?} parent\n     * @param {?} oldChild\n     * @param {?} isHostElement\n     * @return {?}\n     */\n    removeChild(parent, oldChild, isHostElement) {\n        this.engine.onRemove(this.namespaceId, oldChild, this.delegate, isHostElement);\n    }\n    /**\n     * @param {?} selectorOrNode\n     * @param {?=} preserveContent\n     * @return {?}\n     */\n    selectRootElement(selectorOrNode, preserveContent) {\n        return this.delegate.selectRootElement(selectorOrNode, preserveContent);\n    }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    parentNode(node) { return this.delegate.parentNode(node); }\n    /**\n     * @param {?} node\n     * @return {?}\n     */\n    nextSibling(node) { return this.delegate.nextSibling(node); }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?} value\n     * @param {?=} namespace\n     * @return {?}\n     */\n    setAttribute(el, name, value, namespace) {\n        this.delegate.setAttribute(el, name, value, namespace);\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?=} namespace\n     * @return {?}\n     */\n    removeAttribute(el, name, namespace) {\n        this.delegate.removeAttribute(el, name, namespace);\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    addClass(el, name) { this.delegate.addClass(el, name); }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @return {?}\n     */\n    removeClass(el, name) { this.delegate.removeClass(el, name); }\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?} value\n     * @param {?=} flags\n     * @return {?}\n     */\n    setStyle(el, style, value, flags) {\n        this.delegate.setStyle(el, style, value, flags);\n    }\n    /**\n     * @param {?} el\n     * @param {?} style\n     * @param {?=} flags\n     * @return {?}\n     */\n    removeStyle(el, style, flags) {\n        this.delegate.removeStyle(el, style, flags);\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    setProperty(el, name, value) {\n        if (name.charAt(0) == ANIMATION_PREFIX && name == DISABLE_ANIMATIONS_FLAG) {\n            this.disableAnimations(el, !!value);\n        }\n        else {\n            this.delegate.setProperty(el, name, value);\n        }\n    }\n    /**\n     * @param {?} node\n     * @param {?} value\n     * @return {?}\n     */\n    setValue(node, value) { this.delegate.setValue(node, value); }\n    /**\n     * @param {?} target\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    listen(target, eventName, callback) {\n        return this.delegate.listen(target, eventName, callback);\n    }\n    /**\n     * @protected\n     * @param {?} element\n     * @param {?} value\n     * @return {?}\n     */\n    disableAnimations(element, value) {\n        this.engine.disableAnimations(element, value);\n    }\n}\nif (false) {\n    /** @type {?} */\n    BaseAnimationRenderer.prototype.destroyNode;\n    /**\n     * @type {?}\n     * @protected\n     */\n    BaseAnimationRenderer.prototype.namespaceId;\n    /** @type {?} */\n    BaseAnimationRenderer.prototype.delegate;\n    /** @type {?} */\n    BaseAnimationRenderer.prototype.engine;\n}\nclass AnimationRenderer extends BaseAnimationRenderer {\n    /**\n     * @param {?} factory\n     * @param {?} namespaceId\n     * @param {?} delegate\n     * @param {?} engine\n     */\n    constructor(factory, namespaceId, delegate, engine) {\n        super(namespaceId, delegate, engine);\n        this.factory = factory;\n        this.namespaceId = namespaceId;\n    }\n    /**\n     * @param {?} el\n     * @param {?} name\n     * @param {?} value\n     * @return {?}\n     */\n    setProperty(el, name, value) {\n        if (name.charAt(0) == ANIMATION_PREFIX) {\n            if (name.charAt(1) == '.' && name == DISABLE_ANIMATIONS_FLAG) {\n                value = value === undefined ? true : !!value;\n                this.disableAnimations(el, (/** @type {?} */ (value)));\n            }\n            else {\n                this.engine.process(this.namespaceId, el, name.substr(1), value);\n            }\n        }\n        else {\n            this.delegate.setProperty(el, name, value);\n        }\n    }\n    /**\n     * @param {?} target\n     * @param {?} eventName\n     * @param {?} callback\n     * @return {?}\n     */\n    listen(target, eventName, callback) {\n        if (eventName.charAt(0) == ANIMATION_PREFIX) {\n            /** @type {?} */\n            const element = resolveElementFromTarget(target);\n            /** @type {?} */\n            let name = eventName.substr(1);\n            /** @type {?} */\n            let phase = '';\n            // @listener.phase is for trigger animation callbacks\n            // @@listener is for animation builder callbacks\n            if (name.charAt(0) != ANIMATION_PREFIX) {\n                [name, phase] = parseTriggerCallbackName(name);\n            }\n            return this.engine.listen(this.namespaceId, element, name, phase, (/**\n             * @param {?} event\n             * @return {?}\n             */\n            event => {\n                /** @type {?} */\n                const countId = ((/** @type {?} */ (event)))['_data'] || -1;\n                this.factory.scheduleListenerCallback(countId, callback, event);\n            }));\n        }\n        return this.delegate.listen(target, eventName, callback);\n    }\n}\nif (false) {\n    /** @type {?} */\n    AnimationRenderer.prototype.factory;\n}\n/**\n * @param {?} target\n * @return {?}\n */\nfunction resolveElementFromTarget(target) {\n    switch (target) {\n        case 'body':\n            return document.body;\n        case 'document':\n            return document;\n        case 'window':\n            return window;\n        default:\n            return target;\n    }\n}\n/**\n * @param {?} triggerName\n * @return {?}\n */\nfunction parseTriggerCallbackName(triggerName) {\n    /** @type {?} */\n    const dotIndex = triggerName.indexOf('.');\n    /** @type {?} */\n    const trigger = triggerName.substring(0, dotIndex);\n    /** @type {?} */\n    const phase = triggerName.substr(dotIndex + 1);\n    return [trigger, phase];\n}\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/providers.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\nclass InjectableAnimationEngine extends ɵAnimationEngine {\n    /**\n     * @param {?} doc\n     * @param {?} driver\n     * @param {?} normalizer\n     */\n    constructor(doc, driver, normalizer) {\n        super(doc.body, driver, normalizer);\n    }\n}\nInjectableAnimationEngine.decorators = [\n    { type: Injectable }\n];\n/** @nocollapse */\nInjectableAnimationEngine.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },\n    { type: AnimationDriver },\n    { type: ɵAnimationStyleNormalizer }\n];\n/**\n * @return {?}\n */\nfunction instantiateSupportedAnimationDriver() {\n    return ɵsupportsWebAnimations() ? new ɵWebAnimationsDriver() : new ɵCssKeyframesDriver();\n}\n/**\n * @return {?}\n */\nfunction instantiateDefaultStyleNormalizer() {\n    return new ɵWebAnimationsStyleNormalizer();\n}\n/**\n * @param {?} renderer\n * @param {?} engine\n * @param {?} zone\n * @return {?}\n */\nfunction instantiateRendererFactory(renderer, engine, zone) {\n    return new AnimationRendererFactory(renderer, engine, zone);\n}\n/**\n * \\@publicApi\n * @type {?}\n */\nconst ANIMATION_MODULE_TYPE = new InjectionToken('AnimationModuleType');\n/** @type {?} */\nconst SHARED_ANIMATION_PROVIDERS = [\n    { provide: AnimationBuilder, useClass: BrowserAnimationBuilder },\n    { provide: ɵAnimationStyleNormalizer, useFactory: instantiateDefaultStyleNormalizer },\n    { provide: ɵAnimationEngine, useClass: InjectableAnimationEngine }, {\n        provide: RendererFactory2,\n        useFactory: instantiateRendererFactory,\n        deps: [ɵDomRendererFactory2, ɵAnimationEngine, NgZone]\n    }\n];\n/**\n * Separate providers from the actual module so that we can do a local modification in Google3 to\n * include them in the BrowserModule.\n * @type {?}\n */\nconst BROWSER_ANIMATIONS_PROVIDERS = [\n    { provide: AnimationDriver, useFactory: instantiateSupportedAnimationDriver },\n    { provide: ANIMATION_MODULE_TYPE, useValue: 'BrowserAnimations' }, ...SHARED_ANIMATION_PROVIDERS\n];\n/**\n * Separate providers from the actual module so that we can do a local modification in Google3 to\n * include them in the BrowserTestingModule.\n * @type {?}\n */\nconst BROWSER_NOOP_ANIMATIONS_PROVIDERS = [\n    { provide: AnimationDriver, useClass: ɵNoopAnimationDriver },\n    { provide: ANIMATION_MODULE_TYPE, useValue: 'NoopAnimations' }, ...SHARED_ANIMATION_PROVIDERS\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/module.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n/**\n * Exports `BrowserModule` with additional [dependency-injection providers](guide/glossary#provider)\n * for use with animations. See [Animations](guide/animations).\n * \\@publicApi\n */\nclass BrowserAnimationsModule {\n}\nBrowserAnimationsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [BrowserModule],\n                providers: BROWSER_ANIMATIONS_PROVIDERS,\n            },] }\n];\n/**\n * A null player that must be imported to allow disabling of animations.\n * \\@publicApi\n */\nclass NoopAnimationsModule {\n}\nNoopAnimationsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [BrowserModule],\n                providers: BROWSER_NOOP_ANIMATIONS_PROVIDERS,\n            },] }\n];\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/private_export.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/src/animations.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: packages/platform-browser/animations/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ANIMATION_MODULE_TYPE, BrowserAnimationsModule, NoopAnimationsModule, AnimationRenderer as ɵAnimationRenderer, AnimationRendererFactory as ɵAnimationRendererFactory, BrowserAnimationBuilder as ɵBrowserAnimationBuilder, BrowserAnimationFactory as ɵBrowserAnimationFactory, InjectableAnimationEngine as ɵInjectableAnimationEngine, instantiateSupportedAnimationDriver as ɵangular_packages_platform_browser_animations_animations_a, instantiateDefaultStyleNormalizer as ɵangular_packages_platform_browser_animations_animations_b, instantiateRendererFactory as ɵangular_packages_platform_browser_animations_animations_c, BROWSER_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_d, BROWSER_NOOP_ANIMATIONS_PROVIDERS as ɵangular_packages_platform_browser_animations_animations_e, BaseAnimationRenderer as ɵangular_packages_platform_browser_animations_animations_f };\n"]}